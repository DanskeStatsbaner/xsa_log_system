PROCEDURE "DataWareHouse.Database.Procedures::OOM_Events"( )
LANGUAGE SQLSCRIPT
SQL SECURITY INVOKER
AS
BEGIN

DECLARE k, CONN_ID, NUM_OOMS Integer;
DECLARE OOM_TIME,RUNTIME_START, RUNTIME_END, LAST_RUN Timestamp;
DECLARE ingesttoken NVARCHAR(2500);
DECLARE HOST, PORT, STATEMENT_HASH, TRACEFILE_NAME, EVENT_REASON,HANA_LOG_NAME, ENVIRONMENT,  WORKLOAD_CLASS_NAME, EXECUTION_ENGINE,  SCHEMA_NAME  NVARCHAR(250);
DECLARE STATEMENT_STRING NCLOB;
DECLARE HANA_LOG_COMMENT NVARCHAR(500) = '';
DECLARE STATEMENT_ID Bigint;
DECLARE MEM_REQ_GB, MEM_USED_GB, MEM_LIMIT_GB DECIMAL (10,2);

RUNTIME_START = CURRENT_TIMESTAMP;
HANA_LOG_NAME ='OOM_Events';
SELECT IFNULL(MAX("RUNTIME_START"),'2022-01-01 00:00:00') INTO LAST_RUN FROM "DataWareHouse.Database.Tables::log.procedure_run";

		



SAP_TABLE = SELECT
  OOM_TIME,
  HOST,
  STATEMENT_HASH,
  LPAD(STATEMENT_ID, 20) STATEMENT_ID,
  LPAD(NUM_OOMS, 8) NUM_OOMS,
  LPAD(TO_DECIMAL(MEM_REQ_GB, 10, 2), 25) MEM_REQ_GB,
  LPAD(TO_DECIMAL(MEM_USED_GB, 10, 2), 25) MEM_USED_GB,
  LPAD(TO_DECIMAL(MEM_LIMIT_GB, 10, 2), 25) MEM_LIMIT_GB,
  EVENT_REASON,
  TRACEFILE_NAME,
  WORKLOAD_CLASS_NAME
FROM
( SELECT
    CASE 
      WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN 
        CASE 
          WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN
            TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 
            'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(OE.TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE OE.TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS')
          ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(OE.TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE OE.TIME END, BI.TIME_AGGREGATE_BY)
        END
      ELSE 'any' 
    END OOM_TIME,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST')         != 0 THEN OE.HOST           ELSE MAP(BI.HOST, '%', 'any', BI.HOST)                            END HOST,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT')         != 0 THEN OE.PORT           ELSE MAP(BI.PORT, '%', 'any', BI.PORT)                            END PORT,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'CONN_ID')      != 0 THEN OE.CONNECTION_ID  ELSE MAP(BI.CONN_ID, -1, 'any', TO_VARCHAR(BI.CONN_ID))           END CONN_ID,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HASH')         != 0 THEN OE.STATEMENT_HASH ELSE MAP(BI.STATEMENT_HASH, '%', 'any', BI.STATEMENT_HASH)        END STATEMENT_HASH,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'STATEMENT_ID') != 0 THEN OE.STATEMENT_ID   ELSE MAP(BI.STATEMENT_ID, -1, 'any', TO_VARCHAR(BI.STATEMENT_ID)) END STATEMENT_ID,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'REASON')       != 0 THEN OE.EVENT_REASON   ELSE MAP(BI.EVENT_REASON, '%', 'any', BI.EVENT_REASON)            END EVENT_REASON,
    COUNT(*) NUM_OOMS,
    AVG(OE.MEMORY_REQUEST_SIZE) / 1024 / 1024 / 1024 MEM_REQ_GB,
    AVG(OE.MEMORY_USED_SIZE) / 1024 / 1024 / 1024 MEM_USED_GB,
    AVG(OE.MEMORY_LIMIT_SIZE) / 1024 / 1024 / 1024 MEM_LIMIT_GB,
    MAP(MIN(OE.TRACEFILE_NAME), MAX(OE.TRACEFILE_NAME), MIN(OE.TRACEFILE_NAME), 'various') TRACEFILE_NAME,
    WORKLOAD_CLASS_NAME
  FROM
  ( SELECT
      CASE
        WHEN BEGIN_TIME =    'C'                             THEN CURRENT_TIMESTAMP
        WHEN BEGIN_TIME LIKE 'C-S%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-S'))
        WHEN BEGIN_TIME LIKE 'C-M%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-M') * 60)
        WHEN BEGIN_TIME LIKE 'C-H%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-H') * 3600)
        WHEN BEGIN_TIME LIKE 'C-D%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-D') * 86400)
        WHEN BEGIN_TIME LIKE 'C-W%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(BEGIN_TIME, 'C-W') * 86400 * 7)
        WHEN BEGIN_TIME LIKE 'E-S%'                          THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-S'))
        WHEN BEGIN_TIME LIKE 'E-M%'                          THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-M') * 60)
        WHEN BEGIN_TIME LIKE 'E-H%'                          THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-H') * 3600)
        WHEN BEGIN_TIME LIKE 'E-D%'                          THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-D') * 86400)
        WHEN BEGIN_TIME LIKE 'E-W%'                          THEN ADD_SECONDS(TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS'), -SUBSTR_AFTER(BEGIN_TIME, 'E-W') * 86400 * 7)
        WHEN BEGIN_TIME =    'MIN'                           THEN TO_TIMESTAMP('1000/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS')
        WHEN SUBSTR(BEGIN_TIME, 1, 1) NOT IN ('C', 'E', 'M') THEN TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS')
      END BEGIN_TIME,
      CASE
        WHEN END_TIME =    'C'                             THEN CURRENT_TIMESTAMP
        WHEN END_TIME LIKE 'C-S%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-S'))
        WHEN END_TIME LIKE 'C-M%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-M') * 60)
        WHEN END_TIME LIKE 'C-H%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-H') * 3600)
        WHEN END_TIME LIKE 'C-D%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-D') * 86400)
        WHEN END_TIME LIKE 'C-W%'                          THEN ADD_SECONDS(CURRENT_TIMESTAMP, -SUBSTR_AFTER(END_TIME, 'C-W') * 86400 * 7)
        WHEN END_TIME LIKE 'B+S%'                          THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+S'))
        WHEN END_TIME LIKE 'B+M%'                          THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+M') * 60)
        WHEN END_TIME LIKE 'B+H%'                          THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+H') * 3600)
        WHEN END_TIME LIKE 'B+D%'                          THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+D') * 86400)
        WHEN END_TIME LIKE 'B+W%'                          THEN ADD_SECONDS(TO_TIMESTAMP(BEGIN_TIME, 'YYYY/MM/DD HH24:MI:SS'), SUBSTR_AFTER(END_TIME, 'B+W') * 86400 * 7)
        WHEN END_TIME =    'MAX'                           THEN TO_TIMESTAMP('9999/12/31 00:00:00', 'YYYY/MM/DD HH24:MI:SS')
        WHEN SUBSTR(END_TIME, 1, 1) NOT IN ('C', 'B', 'M') THEN TO_TIMESTAMP(END_TIME, 'YYYY/MM/DD HH24:MI:SS')
      END END_TIME,
      TIMEZONE,
      HOST,
      PORT,
      CONN_ID,
      STATEMENT_HASH,
      STATEMENT_ID,
      EVENT_REASON,
      DATA_SOURCE,
      AGGREGATE_BY,
      MAP(TIME_AGGREGATE_BY,
        'NONE',        'YYYY/MM/DD HH24:MI:SS',
        'HOUR',        'YYYY/MM/DD HH24',
        'DAY',         'YYYY/MM/DD (DY)',
        'HOUR_OF_DAY', 'HH24',
        TIME_AGGREGATE_BY ) TIME_AGGREGATE_BY
    FROM
    ( SELECT                              /* Modification section */
        '1000/10/18 07:58:00' BEGIN_TIME,                  /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, E-S<seconds>, E-M<minutes>, E-H<hours>, E-D<days>, E-W<weeks>, MIN */
        '9999/10/18 08:05:00' END_TIME,                    /* YYYY/MM/DD HH24:MI:SS timestamp, C, C-S<seconds>, C-M<minutes>, C-H<hours>, C-D<days>, C-W<weeks>, B+S<seconds>, B+M<minutes>, B+H<hours>, B+D<days>, B+W<weeks>, MAX */
        'SERVER' TIMEZONE,                              /* SERVER, UTC */
        '%' HOST,
        '%' PORT,
        -1 CONN_ID,
        '%' STATEMENT_HASH,
        -1 STATEMENT_ID,
        '%' EVENT_REASON,
        'CURRENT' DATA_SOURCE,
        'NONE' AGGREGATE_BY,         /* TIME, HOST, PORT, CONN_ID, HASH, REASON or comma separated combinations, NONE for no aggregation */
        'NONE' TIME_AGGREGATE_BY     /* HOUR, DAY, HOUR_OF_DAY or database time pattern, TS<seconds> for time slice, NONE for no aggregation */
      FROM
        "DataWareHouse.Database.Synonyms::DUMMY"
    )
  ) BI,
  ( SELECT
      'CURRENT' DATA_SOURCE,
      HOST,
      TO_VARCHAR(PORT) PORT,
      TIME,
      TO_VARCHAR(CONNECTION_ID) CONNECTION_ID,
      STATEMENT_HASH,
      STATEMENT_ID,
      EVENT_REASON,
      MEMORY_REQUEST_SIZE,
      MEMORY_USED_SIZE,
      MEMORY_LIMIT_SIZE,
      TRACEFILE_NAME,
      WORKLOAD_CLASS_NAME
    FROM
      "DataWareHouse.Database.Virtualtables::M_OUT_OF_MEMORY_EVENTS"
    UNION ALL
    SELECT
      'HISTORY' DATA_SOURCE,
      HOST,
      PORT,
      TIME,
      CONNECTION_ID,
      STATEMENT_HASH,
      STATEMENT_ID,
      EVENT_REASON,
      MEMORY_REQUEST_SIZE,
      MEMORY_USED_SIZE,
      MEMORY_LIMIT_SIZE,
      TRACEFILE_NAME,
      WORKLOAD_CLASS_NAME
    FROM
      "DataWareHouse.Database.Virtualtables::GLOBAL_OUT_OF_MEMORY_EVENTS"
  ) OE
  WHERE
    CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(OE.TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE OE.TIME END BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    OE.HOST LIKE BI.HOST AND
    OE.PORT LIKE BI.PORT AND
    ( BI.CONN_ID = -1 OR OE.CONNECTION_ID = TO_VARCHAR(BI.CONN_ID) ) AND
    OE.STATEMENT_HASH LIKE BI.STATEMENT_HASH AND
    ( BI.STATEMENT_ID = -1 OR OE.STATEMENT_ID = BI.STATEMENT_ID ) AND
    OE.EVENT_REASON LIKE BI.EVENT_REASON AND
    OE.DATA_SOURCE LIKE BI.DATA_SOURCE
  GROUP BY
    CASE 
      WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'TIME') != 0 THEN 
        CASE 
          WHEN BI.TIME_AGGREGATE_BY LIKE 'TS%' THEN
            TO_VARCHAR(ADD_SECONDS(TO_TIMESTAMP('2014/01/01 00:00:00', 'YYYY/MM/DD HH24:MI:SS'), FLOOR(SECONDS_BETWEEN(TO_TIMESTAMP('2014/01/01 00:00:00', 
            'YYYY/MM/DD HH24:MI:SS'), CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(OE.TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE OE.TIME END) / SUBSTR(BI.TIME_AGGREGATE_BY, 3)) * SUBSTR(BI.TIME_AGGREGATE_BY, 3)), 'YYYY/MM/DD HH24:MI:SS')
          ELSE TO_VARCHAR(CASE BI.TIMEZONE WHEN 'UTC' THEN ADD_SECONDS(OE.TIME, SECONDS_BETWEEN(CURRENT_TIMESTAMP, CURRENT_UTCTIMESTAMP)) ELSE OE.TIME END, BI.TIME_AGGREGATE_BY)
        END
      ELSE 'any' 
    END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HOST')         != 0 THEN OE.HOST           ELSE MAP(BI.HOST, '%', 'any', BI.HOST)                            END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'PORT')         != 0 THEN OE.PORT           ELSE MAP(BI.PORT, '%', 'any', BI.PORT)                            END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'CONN_ID')      != 0 THEN OE.CONNECTION_ID  ELSE MAP(BI.CONN_ID, -1, 'any', TO_VARCHAR(BI.CONN_ID))           END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'HASH')         != 0 THEN OE.STATEMENT_HASH ELSE MAP(BI.STATEMENT_HASH, '%', 'any', BI.STATEMENT_HASH)        END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'STATEMENT_ID') != 0 THEN OE.STATEMENT_ID   ELSE MAP(BI.STATEMENT_ID, -1, 'any', TO_VARCHAR(BI.STATEMENT_ID)) END,
    CASE WHEN BI.AGGREGATE_BY = 'NONE' OR INSTR(BI.AGGREGATE_BY, 'REASON')       != 0 THEN OE.EVENT_REASON   ELSE MAP(BI.EVENT_REASON, '%', 'any', BI.EVENT_REASON)            END,
     WORKLOAD_CLASS_NAME
)
ORDER BY
  OOM_TIME DESC,
  NUM_OOMS DESC,
  HOST,
  PORT,
  CONN_ID;
  
  
SQL_SNAP =
SELECT DISTINCT
	"EXECUTION_ENGINE",
	"SCHEMA_NAME",
	"STATEMENT_HASH",
	MAX("SNAPSHOT_ID") AS "SNAPSHOT_ID"
FROM "DataWareHouse.Database.Virtualtables::HOST_SQL_PLAN_CACHE" WHERE "STATEMENT_HASH" IN (SELECT DISTINCT "STATEMENT_HASH" FROM :SAP_TABLE)
GROUP BY
	"EXECUTION_ENGINE",
	"SCHEMA_NAME",
	"STATEMENT_HASH"
;

SQL_STAT=
SELECT 
A."SCHEMA_NAME", 
A."EXECUTION_ENGINE",
A."STATEMENT_HASH",
B."STATEMENT_STRING"
FROM :SQL_SNAP A
INNER JOIN  "DataWareHouse.Database.Virtualtables::HOST_SQL_PLAN_CACHE" B ON (A."SNAPSHOT_ID" = B."SNAPSHOT_ID" AND A."STATEMENT_HASH" = B."STATEMENT_HASH")
;


OOM_EVENTS_NO_STATEMENT = 
	SELECT DISTINCT
    MIN(OOM_TIME) OOM_TIME,
    HOST,
    A.STATEMENT_HASH STATEMENT_HASH,
    STATEMENT_ID,
    SUM(TO_INT(NUM_OOMS)) NUM_OOMS,
	AVG(TO_DECIMAL(MEM_REQ_GB)) MEM_REQ_GB,
	AVG(TO_DECIMAL(MEM_USED_GB)) MEM_USED_GB,
	AVG(TO_DECIMAL(MEM_LIMIT_GB)) MEM_LIMIT_GB,
	EVENT_REASON,
	CASE WHEN LENGTH(WORKLOAD_CLASS_NAME) < 1 THEN '-1'
	ELSE WORKLOAD_CLASS_NAME 
	END AS WORKLOAD_CLASS_NAME,
	CASE WHEN LENGTH(MAX(TRACEFILE_NAME)) < 1 THEN '-1'
	ELSE MAX(TRACEFILE_NAME) 
	END AS TRACEFILE_NAME,
	IFNULL(EXECUTION_ENGINE, '-1') EXECUTION_ENGINE,
	IFNULL(SCHEMA_NAME, '-1') SCHEMA_NAME
  FROM :SAP_TABLE A
  LEFT JOIN  :SQL_STAT B ON (A.STATEMENT_HASH = B.STATEMENT_HASH)
  WHERE OOM_TIME > :LAST_RUN
  GROUP BY
   HOST,
   A.STATEMENT_HASH,
   STATEMENT_ID,
   EVENT_REASON,
   WORKLOAD_CLASS_NAME,
   EXECUTION_ENGINE,
   SCHEMA_NAME
   ;
  

OOM_EVENTS =
	SELECT
	A.OOM_TIME,
	A.HOST,
	A.STATEMENT_HASH,
	A.STATEMENT_ID,
	A.NUM_OOMS,
	A.MEM_REQ_GB,
	A.MEM_USED_GB,
	A.MEM_LIMIT_GB,
	A.EVENT_REASON,
	A.WORKLOAD_CLASS_NAME,
	A.TRACEFILE_NAME,
	A.EXECUTION_ENGINE,
	A.SCHEMA_NAME
--	IFNULL(B.STATEMENT_STRING,'-1') STATEMENT_STRING
  FROM :OOM_EVENTS_NO_STATEMENT A
 -- LEFT JOIN  :SQL_STAT B ON (A.STATEMENT_HASH = B.STATEMENT_HASH)
  ;
  
  /*SELECT DISTINCT
	CASE 
		WHEN "HOST" = 'vssapnu001u' THEN 'DEV'
		WHEN "HOST" = 'vssapnt001t'	THEN 'TEST'
		WHEN "HOST" = 'vssapnp001p' THEN 'PRD'
		END AS "Environment" INTO ENVIRONMENT
		FROM :OOM_EVENTS;
  */
  

SELECT DISTINCT
	CASE 
		WHEN "SYSTEM_ID" = 'NU0' THEN 'DEV'
		WHEN "SYSTEM_ID" = 'NT0'	THEN 'TEST'
		WHEN "SYSTEM_ID" = 'NP0' THEN 'PROD'
		END AS "ENVIRONMENT" INTO ENVIRONMENT
		FROM "DataWareHouse.Database.Virtualtables::M_DATABASE";


  
  CALL "DataWareHouse.Database.Synonyms::token"(
	APP => 'AP_HUMIO',
	EXCEPTION_ON_ERROR => 1,
	JWT => ingesttoken
);



IF RECORD_COUNT(:OOM_EVENTS) >= 1 THEN
		FOR k IN 1..RECORD_COUNT(:OOM_EVENTS) DO 
		OOM_TIME = :OOM_EVENTS."OOM_TIME"[:k];
		HOST = :OOM_EVENTS."HOST"[:k];
		STATEMENT_HASH = :OOM_EVENTS."STATEMENT_HASH"[:k];
		STATEMENT_ID = :OOM_EVENTS."STATEMENT_ID"[:k];
		NUM_OOMS = :OOM_EVENTS."NUM_OOMS"[:k];
		MEM_REQ_GB = :OOM_EVENTS."MEM_REQ_GB"[:k];
		MEM_USED_GB = :OOM_EVENTS."MEM_USED_GB"[:k];
		MEM_LIMIT_GB = :OOM_EVENTS."MEM_LIMIT_GB"[:k];
		EVENT_REASON = :OOM_EVENTS."EVENT_REASON"[:k];
		WORKLOAD_CLASS_NAME = :OOM_EVENTS."WORKLOAD_CLASS_NAME"[:k];
		TRACEFILE_NAME = :OOM_EVENTS."TRACEFILE_NAME"[:k];
		EXECUTION_ENGINE = :OOM_EVENTS."EXECUTION_ENGINE"[:k];
		SCHEMA_NAME = :OOM_EVENTS."SCHEMA_NAME"[:k];
	--	STATEMENT_STRING = :OOM_EVENTS."STATEMENT_STRING"[:k];
			CALL "DataWareHouse.Database.Synonyms::humio"(
    MESSAGE => 'Native HANA system log',
    LOG_LEVEL => 'WARNING',
    HOST => 'HANA',
    SRC => 'OOM_Events.hdbprocedure',
       ATTRIBUTES => '"ENVIRONMENT":"' || :ENVIRONMENT || '", "OOM_TIME":"' || :OOM_TIME || '", "HOST":"' || :HOST || '", "STATEMENT_HASH":"' || :STATEMENT_HASH || '", "STATEMENT_ID":"' || :STATEMENT_ID  || '", "NUM_OOMS":"' || :NUM_OOMS 
       || '", "MEM_REQ_GB":"' || :MEM_REQ_GB || '", "MEM_USED_GB":"' || :MEM_USED_GB ||  '", "MEM_LIMIT_GB":"' || :MEM_LIMIT_GB || '", "EVENT_REASON":"' || :EVENT_REASON || '", "WORKLOAD_CLASS_NAME":"' || :WORKLOAD_CLASS_NAME || '", "TRACEFILE_NAME":"' || :TRACEFILE_NAME 
       || '", "EXECUTION_ENGINE":"' || :EXECUTION_ENGINE || '", "SCHEMA_NAME":"' || :SCHEMA_NAME --|| '", "STATEMENT_STRING":"' || :STATEMENT_STRING
       ||'"',
    JWT => :ingesttoken,
    EXCEPTION_ON_ERROR => 1
);
		END FOR;
	
	END IF; 
  RUNTIME_END = CURRENT_TIMESTAMP;
	INSERT INTO "DataWareHouse.Database.Tables::log.procedure_run" ("NAME", "RUNTIME_START", "RUNTIME_END", "COMMENT") VALUES(:HANA_LOG_NAME, :RUNTIME_START, :RUNTIME_END, :HANA_LOG_COMMENT);	
  
END